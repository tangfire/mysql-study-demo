以下是对 **MySQL 单列索引与联合索引的选择策略** 的深度解析，结合核心场景与性能优化原则：

---

### 一、单列索引与联合索引的定义
1. **单列索引**
    - 仅对单个字段建立的索引，例如 `INDEX(name)`。
    - **适用场景**：高频的单字段查询（如 `WHERE name = 'John'`）或排序操作（如 `ORDER BY age`）。

2. **联合索引**
    - 对多个字段组合建立的索引，例如 `INDEX(name, age)`。
    - **核心规则**：遵循 **最左前缀原则**，即查询条件需从索引最左列开始才能命中。
    - **适用场景**：多条件组合查询（如 `WHERE name = 'John' AND age > 25`）或覆盖索引优化。

---

### 二、选择策略与核心原则
#### 1. **高频查询条件优先**
- **单列索引选择**：若某字段单独作为查询条件的频率极高（如用户 ID），优先建立单列索引。
- **联合索引选择**：若多个字段常组合出现（如 `WHERE city='北京' AND salary>10000`），建立联合索引更高效。
- **示例**：
  ```sql
  -- 高频组合查询场景
  CREATE INDEX idx_city_salary ON employees(city, salary);
  ```

#### 2. **数据区分度与字段顺序**
- **区分度高列优先**：在联合索引中，将选择性高（唯一值多）的字段放在左侧。例如 `INDEX(gender, birthdate)` 效率低于 `INDEX(birthdate, gender)`，因为出生日期的区分度更高。
- **避免冗余索引**：若已存在联合索引 `(A, B)`，则单独为 `A` 建立单列索引是冗余的。

#### 3. **覆盖索引优化**
- **定义**：若查询所需字段均在索引中，无需回表，可显著提升性能。
- **策略**：将 `SELECT` 子句中的字段纳入联合索引。
  ```sql
  -- 覆盖索引示例（查询 name 和 age）
  CREATE INDEX idx_name_age ON users(name, age);
  SELECT name, age FROM users WHERE name = 'John';  -- 直接通过索引返回数据
  ```

#### 4. **范围查询的影响**
- **单列索引局限**：若查询包含范围条件（如 `age > 30`），后续字段无法使用索引。
- **联合索引优化**：将等值查询字段放在范围字段之前。例如：
  ```sql
  -- 优化前：范围查询导致后续索引失效
  CREATE INDEX idx_age_city ON users(age, city);
  SELECT * FROM users WHERE age > 30 AND city = '北京';  -- city 无法使用索引

  -- 优化后：调整字段顺序
  CREATE INDEX idx_city_age ON users(city, age);
  SELECT * FROM users WHERE city = '北京' AND age > 30;  -- 联合索引生效
  ```

#### 5. **维护成本权衡**
- **写入性能**：联合索引的字段越多，插入、更新、删除操作的开销越大。
- **存储成本**：联合索引占用空间通常大于单列索引之和，需评估存储资源。

---

### 三、典型场景对比
| **场景**                | **单列索引**                     | **联合索引**                     |
|-------------------------|----------------------------------|----------------------------------|
| 高频单字段查询          | ✅ 命中率高                      | ❌ 可能冗余                     |
| 多字段等值查询          | ❌ 需多次回表                    | ✅ 一次索引扫描完成             |
| 排序 + 过滤             | ❌ 可能触发文件排序（`filesort`）| ✅ 利用索引顺序直接排序          |
| 长文本字段查询          | ✅ 可搭配前缀索引                | ❌ 联合索引体积过大，不推荐      |

---

### 四、最佳实践建议
1. **分析查询模式**：通过慢查询日志或 `EXPLAIN` 定位高频 SQL，针对性设计索引。
2. **优先联合索引**：对多条件查询优先使用联合索引，减少索引数量和维护成本。
3. **避免过度索引**：单表索引数量建议不超过 5 个，单个联合索引字段不超过 3 个。
4. **定期优化**：通过 `ANALYZE TABLE` 更新统计信息，删除无效索引。

---

### 总结
单列索引与联合索引的选择需遵循 **高频优先、区分度优先、覆盖优先** 三大原则，同时兼顾维护成本。核心策略包括：
- 高频单字段查询 → 单列索引；
- 多条件组合查询 → 联合索引（注意字段顺序与范围查询影响）；
- 覆盖查询 → 扩展联合索引字段。

建议结合 `EXPLAIN` 分析执行计划，动态调整索引策略。