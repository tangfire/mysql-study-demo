



### MySQL 索引使用规则详解

#### 一、索引类型与核心规则
1. **索引分类**  
   • **普通索引**：仅加速查询，允许重复值和空值。  
   • **唯一索引**：保证列值唯一性（允许空值），常用于避免数据重复。  
   • **主键索引**：特殊的唯一索引，不允许空值且每个表仅一个，InnoDB中作为聚簇索引存储数据行。  
   • **复合索引**：覆盖多列的索引，遵循**最左前缀法则**（查询需从索引最左列开始，不可跳跃中间列）。  
   • **覆盖索引**：查询字段全部在索引中，避免回表操作。  
   • **全文索引**：针对文本字段（如`TEXT`）的模糊搜索，支持自然语言查询。

2. **最左前缀法则**  
   • **核心规则**：联合索引的查询必须从最左列开始，且不能跳过中间列。  
   ◦ 示例：索引`(a, b, c)`，查询`a=1 AND c=3`仅使用`a`列索引；若跳过`b`，`c`失效。  
   • **范围查询截断**：范围查询（`>`, `<`, `BETWEEN`）后的列无法使用索引。  
   ◦ 示例：索引`(a, b, c)`，查询`a=1 AND b>2 AND c=3`仅`a`和`b`有效，`c`需回表过滤。

---

#### 二、索引创建与使用原则
1. **创建规则**  
   • **高区分度列优先**：选择`COUNT(DISTINCT column)/COUNT(*)`值高的列，减少扫描行数。  
   • **避免冗余索引**：扩展已有索引（如将单列索引`a`升级为`(a, b)`），而非新建索引。  
   • **前缀索引**：对长字符串字段（如`VARCHAR(200)`）取前N个字符创建索引，节省空间。

2. **使用原则**  
   • **禁止列计算**：索引列参与函数或表达式时失效。  
   ◦ 错误示例：`WHERE YEAR(create_time)=2023` → 应改为`create_time BETWEEN '2023-01-01' AND '2023-12-31'`。  
   • **避免全模糊查询**：`LIKE '%keyword%'`无法使用索引，`LIKE 'keyword%'`可触发前缀匹配。  
   • **谨慎使用`OR`条件**：若`OR`两侧字段均无索引，导致全表扫描。

---

#### 三、索引失效场景与优化
1. **常见失效原因**  
   • **列跳跃**：未按联合索引顺序查询（如索引`(a, b, c)`但查询`b=2`）。  
   • **类型不匹配**：字段类型隐式转换（如字符串列用数字查询）。  
   • `NULL`值处理：唯一索引允许`NULL`重复，但可能导致查询优化器弃用索引。  
   • **索引列对比**：`WHERE a = b`（若`a`和`b`均为索引列）可能失效。

2. **优化策略**  
   • **覆盖索引优化**：仅查询索引包含的字段，减少回表次数。  
   ◦ 示例：索引`(a, b)`，查询`SELECT a, b FROM table`可完全通过索引完成。  
   • **索引下推（ICP）**：MySQL 5.6+特性，将过滤条件下推到存储引擎层，减少回表数据量。  
   • **强制索引**：通过`FORCE INDEX`指定索引（需谨慎使用）。

---

#### 四、索引设计与维护建议
1. **设计原则**  
   • **高频查询列前置**：复合索引中，高频精确匹配列放在左侧。  
   • **控制索引数量**：过多索引增加写操作开销，建议单表索引不超过5个。  
   • **分区表优化**：对时间序列数据按月份分区，减少范围查询扫描量。

2. **维护工具**  
   • **执行计划分析**：使用`EXPLAIN`查看`key`（使用的索引）、`key_len`（索引长度）和`Extra`（是否覆盖索引）。  
   • **统计信息更新**：定期执行`ANALYZE TABLE`更新统计信息，帮助优化器选择最佳索引。

---

### 总结
MySQL索引的高效使用需结合**索引类型选择**、**查询条件设计**和**统计信息维护**。重点注意最左前缀法则、范围查询截断和覆盖索引优化，避免常见失效场景。通过`EXPLAIN`分析执行计划，定期优化索引结构，可显著提升查询性能。