### MySQL 表级锁详解

表级锁是 MySQL 中锁定粒度较大的锁机制，**锁定整张表**，适用于全表操作或结构变更场景。以下是其核心特性、类型及使用场景的详细解析：

---

#### 一、表级锁的**核心特性**
1. **锁定范围**  
   对整张表加锁，无论操作涉及多少行数据，均锁定全表。
2. **实现效率**
    - **优点**：加锁快、开销低（仅需维护表级锁状态）。
    - **缺点**：并发度低，高并发场景易引发锁冲突。
3. **支持引擎**  
   MyISAM 默认使用表级锁；InnoDB 支持表级锁，但默认使用行级锁。

---

#### 二、表级锁的**主要类型**
表级锁包含以下 4 种类型：

| **类型**        | **作用**                                                                 | **兼容性**                                 | **典型场景**               |
|-----------------|-------------------------------------------------------------------------|-------------------------------------------|---------------------------|
| **普通表锁**    | 显式锁定整张表（读/写锁），限制其他会话的读写操作。               | 读锁共享，写锁互斥                         | 全表数据迁移、批量更新     |
| **元数据锁（MDL）** | 隐式锁，防止表结构变更（如 `ALTER TABLE`）与数据操作（如 `SELECT`）冲突。 | 读锁（CRUD）与写锁（DDL）互斥              | 表结构变更时避免数据不一致 |
| **意向锁**      | 快速判断表级锁与行级锁的兼容性（如事务加行锁前自动加意向锁）。     | 意向共享锁（IS）与意向排他锁（IX）互相兼容 | 优化行级锁与表级锁的共存   |
| **AUTO-INC 锁** | 确保自增字段（如主键）的唯一性，防止并发插入导致重复值。            | 特殊表级锁，仅自增操作时触发               | 高并发插入自增主键表       |

---

#### 三、表级锁的**操作语法**
1. **显式加锁与释放**
   ```sql
   -- 加读锁（共享锁）
   LOCK TABLES table_name READ;
   
   -- 加写锁（排他锁）
   LOCK TABLES table_name WRITE;
   
   -- 释放锁
   UNLOCK TABLES;
   ```
    - **注意**：加锁会话执行写操作时，自身也会被锁阻塞（如 `LOCK TABLES ... READ` 后无法执行 `UPDATE`）。

2. **隐式锁（MDL）**
    - **自动加锁**：执行 `SELECT` 时加 MDL 读锁，执行 `ALTER TABLE` 时加 MDL 写锁。
    - **释放时机**：事务提交后自动释放，长事务可能导致 MDL 锁阻塞其他操作。

---

#### 四、表级锁的**适用场景**
1. **全表操作**
    - MyISAM 表的批量数据导入/导出。
    - 统计类查询（如 `SELECT COUNT(*)`）需冻结全表数据。
2. **结构变更**  
   执行 `ALTER TABLE`、`DROP TABLE` 等 DDL 操作时，MDL 写锁防止数据读写冲突。
3. **低并发写场景**  
   MyISAM 表在写少读多的应用中，表级锁开销低且易维护。

---

#### 五、表级锁与行级锁的**对比**
| **维度**       | **表级锁**                          | **行级锁**                          |
|----------------|-------------------------------------|-------------------------------------|
| **锁定粒度**   | 整表                                | 单行或多行                          |
| **并发性能**   | 低（锁冲突概率高）                  | 高（锁冲突概率低）                  |
| **适用引擎**   | MyISAM（默认）、InnoDB（支持）      | InnoDB（默认）                      |
| **索引依赖**   | 无关（直接锁表）                    | 必须基于索引（否则退化为表锁） |
| **死锁风险**   | 无                                  | 有（需事务超时或死锁检测）  |

---

#### 六、**使用注意事项**
1. **避免长事务**  
   长事务持有 MDL 锁可能导致后续 DDL 操作阻塞（如 `ALTER TABLE` 超时）。
2. **优先使用 InnoDB**  
   高并发场景下，InnoDB 的行级锁性能显著优于表级锁。
3. **索引优化**  
   若必须使用表级锁，确保操作条件命中索引，避免锁升级（如 InnoDB 无索引时退化为表锁）。

---

### 总结
表级锁通过牺牲并发度换取低开销的特性，适用于全表操作、结构变更等场景。在 MyISAM 引擎中仍是核心锁机制，而 InnoDB 中需结合行级锁灵活使用。开发者应根据业务需求选择合适的锁策略，平衡性能与数据一致性。